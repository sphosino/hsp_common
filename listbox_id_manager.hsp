#ifndef listbox_id_manager
#addition "id_manager.hsp"
#module listbox_id_manager id_to_listnum, listnum_to_id, listnum, id_list_manager, len, filtered_ids, filtered_count, is_filtered, filtered_id_to_listnum, filtered_listnum_to_id, filtered_listnum, sort_keys, is_sorted, sort_order
#const DEFAULT_SIZE 200
#const EXP_RATE 2.0
#const global LISTBOX_SORT_ASC 0
#const global LISTBOX_SORT_DESC 1
#define ctype ceil(%1) ((%1 > int(%1)) + %1)
#modinit int p1
	if p1 == 0{
		newmod id_list_manager, id_manager
		dim id_to_listnum, get_id_length(id_list_manager)
		dim listnum_to_id, get_id_length(id_list_manager)
	}else: if p1 < 0 {
		newmod id_list_manager, id_manager, DEFAULT_SIZE
		dim id_to_listnum, DEFAULT_SIZE
		dim listnum_to_id, DEFAULT_SIZE
	}else{
		newmod id_list_manager, id_manager, p1
		dim id_to_listnum, p1
		dim listnum_to_id, p1
	}
	len = get_id_length(id_list_manager)
	
	; フィルター用の変数を初期化
	dim filtered_ids, len
	filtered_count = 0
	is_filtered = 0
	dim filtered_id_to_listnum, len
	dim filtered_listnum_to_id, len
	filtered_listnum = 0
	
	; ソート用の変数を初期化
	dim sort_keys, len
	is_sorted = 0
	sort_order = LISTBOX_SORT_ASC
	return
	
#modcfunc get_new_listbox_id
	id = get_new_id(id_list_manager)
	
	
	if id >= len || listnum >= len{
		new_len = ceil(EXP_RATE * len)
		id_to_listnum(new_len - 1) = 0
		listnum_to_id(new_len - 1) = 0
		; フィルター配列もリサイズ
		filtered_ids(new_len - 1) = 0
		filtered_id_to_listnum(new_len - 1) = 0
		filtered_listnum_to_id(new_len - 1) = 0
		; ソート配列もリサイズ
		sort_keys(new_len - 1) = 0
		len = new_len
	}
    
	id_to_listnum(id) = listnum
	listnum_to_id(listnum) = id
	listnum++
	
	; フィルターまたはソートが有効な場合は再構築
	if is_filtered || is_sorted {
		_rebuild_display_list thismod
	}
	return id
	
#modfunc delete_listbox_num int p1
	if p1 < 0 : return
	
	; 表示状態に応じて処理を分岐
	if is_filtered || is_sorted {
		if p1 >= filtered_listnum : return
		id = filtered_listnum_to_id(p1)
	} else {
		if p1 >= listnum : return
		id = listnum_to_id(p1)
	}
	
	if is_id_alive(id_list_manager, id) {
		release_id id_list_manager, id
		
		; 元のリストから削除
		original_listnum = id_to_listnum(id)
		repeat listnum - original_listnum - 1, original_listnum
			listnum_to_id(cnt) = listnum_to_id(cnt + 1)
			id_to_listnum(listnum_to_id(cnt)) = cnt
		loop
		listnum--
		
		; フィルターまたはソートが有効な場合は再構築
		if is_filtered || is_sorted {
			_rebuild_display_list thismod
		}
	}
	return

#modfunc delete_listbox_id int p1
	if is_id_alive(id_list_manager, p1){
		if is_filtered || is_sorted {
			; 表示状態では filtered_id_to_listnum を使用
			display_num = _get_display_listnum(thismod, p1)
			if display_num >= 0 {
				delete_listbox_num thismod, display_num
			}
		} else {
			delete_listbox_num thismod, id_to_listnum(p1)
		}
	}
	return

#modfunc clear_listbox_id_manager
	clear_id_manager id_list_manager
	listnum = 0
	filtered_count = 0
	is_filtered = 0
	filtered_listnum = 0
	is_sorted = 0
	return

#modcfunc get_listbox_count
	if is_filtered || is_sorted {
		return filtered_listnum
	}
	return listnum

#modcfunc get_listbox_length
	return len

#modcfunc get_listbox_ids array a, int original
	if (is_filtered || is_sorted) && original == 0{
		if filtered_listnum > 0 {
			a(filtered_listnum - 1) = 0
			memcpy a, filtered_listnum_to_id, filtered_listnum << 2
		}
		return filtered_listnum
	} else {
		if listnum > 0 {
			a(listnum - 1) = 0
			memcpy a, listnum_to_id, listnum << 2
		}
		return listnum
	}
    
#modcfunc get_listbox_ids_range array a, int start_index, int end_index
	if start_index > end_index : return 0
	
	if is_filtered || is_sorted {
		start_idx = limit(start_index, 0, filtered_listnum - 1)
		end_idx = limit(end_index, 0, filtered_listnum - 1)
		n = end_idx - start_idx + 1
		if n > 0 {
			a(n - 1) = 0
			memcpy a, filtered_listnum_to_id, n << 2,, start_idx << 2
		}
		return n
	} else {
		start_idx = limit(start_index, 0, listnum - 1)
		end_idx = limit(end_index, 0, listnum - 1)
		n = end_idx - start_idx + 1
		if n > 0 {
			a(n - 1) = 0
			memcpy a, listnum_to_id, n << 2,, start_idx << 2
		}
		return n
	}
    
#modcfunc get_listbox_id int p1
	if is_filtered || is_sorted {
		if p1 < 0 || p1 >= filtered_listnum : return -1
		return filtered_listnum_to_id(p1)
	} else {
		if p1 < 0 || p1 >= listnum : return -1
		return listnum_to_id(p1)
	}
	
#modcfunc get_listbox_num int p1
	if is_id_alive(id_list_manager, p1) {
		if is_filtered || is_sorted {
			return _get_display_listnum(thismod, p1)
		} else {
			return id_to_listnum(p1)
		}
	}
	return -1

; フィルター機能
#modfunc listbox_filter_on array id_array, int _filtered_count
	; フィルター用IDリストを設定
	if _filtered_count < 0{
		filtered_count = length(id_array)
	}else{
		filtered_count = _filtered_count
	}
	if filtered_count > len {
		; 配列サイズが足りない場合は拡張
		new_len = filtered_count
		filtered_ids(new_len - 1) = 0
		filtered_id_to_listnum(new_len - 1) = 0
		filtered_listnum_to_id(new_len - 1) = 0
		sort_keys(new_len - 1) = 0
		len = new_len
	}
	
	memcpy filtered_ids, id_array, filtered_count << 2
	is_filtered = 1
	_rebuild_display_list thismod
	return

#modfunc listbox_filter_off
	is_filtered = 0
	filtered_count = 0
	filtered_listnum = 0
	; ソートのみが有効な場合は再構築
	if is_sorted {
		_rebuild_display_list thismod
	}
	return

; ソート機能
#modfunc listbox_sort_on array key_array, int order, int is_id_indexed
	; ソートキー配列を設定
	array_size = length(key_array)
	
	/* 必要に応じて内部配列を拡張
	if len < get_id_length(id_list_manager) {
		new_len = get_id_length(id_list_manager)
		sort_keys(new_len - 1) = 0
		filtered_ids(new_len - 1) = 0
		filtered_id_to_listnum(new_len - 1) = 0
		filtered_listnum_to_id(new_len - 1) = 0
		len = new_len
		end
	}
	;*/
	
	; is_id_indexed が 1 の場合、または配列サイズがlen以上の場合はそのままコピー
	if is_id_indexed || array_size >= len {
		memcpy sort_keys, key_array, len << 2
	} else {
		; 配列が不足している場合は変換処理
		_convert_to_id_indexed thismod, key_array, array_size
	}
	
	sort_order = order
	is_sorted = 1
	_rebuild_display_list thismod
	return

#modfunc listbox_shuffle
    if is_filtered {
	    if filtered_listnum{
	        repeat filtered_listnum - 1
	            v = filtered_listnum_to_id(cnt)
	            index = rnd(filtered_listnum - cnt) + cnt
	            filtered_listnum_to_id(cnt) = filtered_listnum_to_id(index)
	            filtered_listnum_to_id(index) = v
	        loop
	        ; フィルタ状態では逆引きテーブルを手動更新
	        repeat filtered_listnum
	            id = filtered_listnum_to_id(cnt)
	            filtered_id_to_listnum(id) = cnt
	        loop
	   }
    } else {
        if listnum {
            repeat listnum - 1
                v = listnum_to_id(cnt)
                index = rnd(listnum - cnt) + cnt
                listnum_to_id(cnt) = listnum_to_id(index)
                listnum_to_id(index) = v
            loop
            repeat listnum
                id = listnum_to_id(cnt)
                id_to_listnum(id) = cnt
            loop
        }
    }
    is_sorted = 0
    ; シャッフル後は再構築不要（既に更新済み）
    return

; 内部関数：リスト順序の配列をID位置配列に変換
#modfunc local _convert_to_id_indexed array source_array, int source_size
	; sort_keysを初期化
	repeat len
		sort_keys(cnt) = 0
	loop
	
	; 現在の表示順序に基づいて変換
	convert_count = 0
	if is_filtered {
		; フィルター状態の場合
		repeat filtered_listnum
			if convert_count >= source_size : break
			id = filtered_listnum_to_id(cnt)
			sort_keys(id) = source_array(convert_count)
			convert_count++
		loop
	} else {
		; 通常状態の場合
		repeat listnum
			if convert_count >= source_size : break
			id = listnum_to_id(cnt)
			sort_keys(id) = source_array(convert_count)
			convert_count++
		loop
	}
	return

#modfunc listbox_sort_off
	is_sorted = 0
	; フィルターのみが有効な場合は再構築
	if is_filtered {
		_rebuild_display_list thismod
	} else {
		filtered_listnum = 0
	}
	return

; 内部関数：表示リストを再構築（フィルター＋ソート対応）
#modfunc local _rebuild_display_list
	filtered_listnum = 0
	
	; まずフィルター処理
	if is_filtered {
		; フィルターされたIDリストから有効なものを抽出
		repeat filtered_count
			filter_id = filtered_ids(cnt)
			if is_id_alive(id_list_manager, filter_id) {
				filtered_listnum_to_id(filtered_listnum) = filter_id
				filtered_listnum++
			}
		loop
	} else {
		; フィルターなしの場合は全てのIDを対象
		repeat listnum
			filtered_listnum_to_id(filtered_listnum) = listnum_to_id(cnt)
			filtered_listnum++
		loop
	}

	; ソート処理
	if (is_sorted != 0) && filtered_listnum > 1 {
		_sort_display_list thismod
		
	}
	
	; filtered_id_to_listnum を更新
	repeat filtered_listnum
		id = filtered_listnum_to_id(cnt)
		filtered_id_to_listnum(id) = cnt
	loop
	return

; 内部関数：表示リストをソート（マージソート）
#modfunc local _sort_display_list
	dim temp_arr, filtered_listnum
	_merge_sort thismod, 0, filtered_listnum - 1, temp_arr
	return

; マージソートの再帰関数
#modfunc local _merge_sort int left, int right, array temp_array, local _mid
	if left >= right : return
	
	_mid = (left + right) / 2
	_merge_sort thismod, left, _mid, temp_array
	_merge_sort thismod, _mid + 1, right, temp_array
	_merge thismod, left, _mid, right, temp_array
	return

; マージ処理
#modfunc local _merge int left, int mid, int right, array temp_array
	; 一時配列に左半分をコピー
	repeat mid - left + 1
		temp_array(cnt) = filtered_listnum_to_id(left + cnt)
	loop
	
	i = 0                    ; 左半分のインデックス
	j = mid + 1              ; 右半分のインデックス
	k = left                 ; マージ先のインデックス
	left_size = mid - left + 1
	
	; 左半分と右半分をマージ
	while i < left_size && j <= right
		id1 = temp_array(i)
		id2 = filtered_listnum_to_id(j)
		key1 = sort_keys(id1)
		key2 = sort_keys(id2)
		
		should_use_left = 0
		if sort_order == LISTBOX_SORT_ASC {
			if key1 <= key2 : should_use_left = 1
		} else {
			if key1 >= key2 : should_use_left = 1
		}
		
		if should_use_left {
			filtered_listnum_to_id(k) = id1
			i++
		} else {
			filtered_listnum_to_id(k) = id2
			j++
		}
		k++
	wend
	
	; 左半分の残りをコピー
	while i < left_size
		filtered_listnum_to_id(k) = temp_array(i)
		i++
		k++
	wend
	
	; 右半分は既に正しい位置にあるので処理不要
	return

; 内部関数：表示状態でのlistnum取得
#modcfunc local _get_display_listnum int target_id
	for i,, filtered_listnum
		if filtered_listnum_to_id(i) == target_id {
			return i
		}
	next
	return -1

#global
#endif