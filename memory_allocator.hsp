#ifndef memory_allocator
#addition "id_manager.hsp"
#module memory_allocator

 #define DEBUG_ALLOCATOR

#const CLASS_NUM 5
#const FREELIST_THRESHOLD 32
#const DEFAULT_POOL_SIZE 180000000
#const MAX_DIV 25000 //ç·ãƒ–ãƒ­ãƒƒã‚¯æ•°
#const MAX_EXPAND_LIMIT 180000000

#const OFFSET_SENTINEL -1234567
#const MEM_SENTINEL_SIZE -9999999

#enum STATE_SENTINEL 0
#enum STATE_USED
#enum STATE_FREE

#deffunc init_memory_pool int size
	
	if size <= 0{
		sdim memory_pool, DEFAULT_POOL_SIZE
	}else{
		sdim memory_pool, size
	}
	
	dim offset, MAX_DIV //ãƒ¡ãƒ¢ãƒªãƒ—ãƒ¼ãƒ«ä¸Šã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	dim mem_size, MAX_DIV //ãƒ¡ãƒ¢ãƒªã®ã‚µã‚¤ã‚º
	dim block_state, MAX_DIV //ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒç©ºãã‹ã©ã†ã‹
	dim back_mem_id, MAX_DIVã€€//å‰ã®ãƒ–ãƒ­ãƒƒã‚¯id
	dim next_mem_id, MAX_DIVã€€//æ¬¡ã®ãƒ–ãƒ­ãƒƒã‚¯id

	dim next_free_list, MAX_DIV
	dim back_free_list, MAX_DIV
	
	dim mem_id_manager
	newmod mem_id_manager, id_manager, MAX_DIV	

	pre_sentinel = -1
	repeat CLASS_NUM
		sentinel(cnt) = get_new_id(mem_id_manager) //ç•ªå…µç”¨ã®IDã‚’ç¢ºä¿

		back_free_list(sentinel(cnt)) = pre_sentinel
		if cnt{
			next_free_list(pre_sentinel) = sentinel(cnt)
		}

		block_state(sentinel(cnt)) = STATE_SENTINEL
		back_mem_id(sentinel(cnt)) = -1
		next_mem_id(sentinel(cnt)) = -1
		offset(sentinel(cnt)) = OFFSET_SENTINEL
		mem_size(sentinel(cnt)) = MEM_SENTINEL_SIZE
		
		pre_sentinel = sentinel(cnt)
	loop
	
	next_free_list(sentinel(CLASS_NUM-1)) = -1


	//æœ€å¾Œã®ãƒ–ãƒ­ãƒƒã‚¯ç®¡ç†å¤‰æ•°
	last_block_id = -1
	
	return

#defcfunc local get_class_index int size
	#ifdef DEBUG_ALLOCATOR
	if size < 0{
		logmes "ERRORï¼ã‚µã‚¤ã‚ºãŒãƒã‚¤ãƒŠã‚¹ã§å‘¼ã°ã‚Œã¾ã—ãŸã€‚æƒ³å®šã—ã¦ã„ãªã„å‡¦ç†ã§ã™\nã‚³ãƒ¼ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚’ç¢ºèªã—ã¦åŸå› ã‚’ç‰¹å®šã—ã¦ãã ã•ã„\n" + pattern_flag + " : " + right + " : " + left
		stop
	}
	#endif
	if size <= 0: return 0
	return limit(logf(size)/logf(2) - 5, 0, CLASS_NUM - 1)
	
#defcfunc get_class_index_by_id int id
	return get_class_index(mem_size(id))
	
#deffunc debug_check_free_list_integrity

	//ç•ªå…µå˜å“æ¤œæŸ»ï¼ˆå›ºå®šã®æƒ…å ±ãŒã„ã˜ã‚‰ã‚Œã¦ã„ãªã„ã‹ï¼Ÿï¼‰
	repeat CLASS_NUM
		if BLOCK_STATE(sentinel(cnt)) != STATE_SENTINEL: logmes "ç•ªå…µãŒå£Šã‚Œã¦ã¾ã™": stop
		if back_mem_id(sentinel(cnt)) != -1: logmes "ç•ªå…µãŒå£Šã‚Œã¦ã„ã¾ã™": stop
		if next_mem_id(sentinel(cnt)) != -1: logmes "ç•ªå…µãŒå£Šã‚Œã¦ã„ã¾ã™": stop
		if offset(sentinel(cnt)) != OFFSET_SENTINEL: logmes "ç•ªå…µãŒå£Šã‚Œã¦ã„ã¾ã™": stop
		if mem_size(sentinel(cnt)) != MEM_SENTINEL_SIZE: logmes "ç•ªå…µãŒå£Šã‚Œã¦ã„ã¾ã™": stop
	loop

	dim id_check, get_max_id(mem_id_manager) + 1 //ç™ºè¡Œã—ãŸIDã®æœ€å¤§å€¤åˆ†ç¢ºä¿

	sentinel_count = 0
	start_point = sentinel(0)
	while start_point >= 0

		id_check(start_point)++
		if id_check(start_point) >= 2{
			logmes "é‡è¤‡ç™»éŒ²ã‚’ç™ºè¦‹ã—ã¾ã—ãŸ"
			stop
		}

		if next_free_list(start_point) >= 0 {
			if back_free_list(next_free_list(start_point)) != start_point {
				logmes "nextâ†’back ãŒä¸€è‡´ã—ã¾ã›ã‚“ at ID=" + start_point
				stop
			}
		}
		if back_free_list(start_point) >= 0 {
			if next_free_list(back_free_list(start_point)) != start_point {
				logmes "backâ†’next ãŒä¸€è‡´ã—ã¾ã›ã‚“ at ID=" + start_point
				stop
			}
		}

		switch block_state(start_point)

		case STATE_FREE
			assert next_mem_id(start_point) >= 0
			assert block_state(next_mem_id(start_point)) == STATE_USED
		swbreak
		case STATE_SENTINEL
			sentinel_count++
		swbreak
		case STATE_USED
			logmes "ä½¿ç”¨ä¸­ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã«å…¥ã£ã¦ã„ã¾ã™\n ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·â†’" + start_point
			stop
		swbreak
		default
			logmes "ä¸æ˜ãªãƒ–ãƒ­ãƒƒã‚¯ãŒãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã«å…¥ã£ã¦ã„ã¾ã™\n ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·â†’" + start_point + "\n ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ—â†’" + block_stat(start_point)
			stop
		swbreak
		swend
			
		start_point = next_free_list(start_point)
	wend

	if sentinel_count != CLASS_NUM{
		logmes "ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆå†…ã®ç•ªå…µã®æ•°ãŒç•°å¸¸ã§ã™\n expected = " + CLASS_NUM + "\n actual = " + sentinel_count
		stop
	}

	return
	
#deffunc remove_from_free_list int id, local class_id

<<<<<<< HEAD
	//ƒtƒŠ[ƒŠƒXƒg‚©‚çíœ‚·‚éA‘S‘Ì‚Ì‘OŒã‚ÌŒ‹‡‚ÍŒÄ‚Ño‚µŒ³‚Ås‚¤B

=======
	//ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤ã™ã‚‹ã€ãã‚Œã ã‘ãªã®ã§ã€å…¨ä½“ã®å‰å¾Œã®çµåˆã¯å‘¼ã³å‡ºã—å…ƒã§è¡Œã†ã“ã¨ã€‚
>>>>>>> 84ab227fc0a0b60992330d10e6da4dcf9a8ee722
	if block_state(id) != STATE_FREE {
		if block_state(id) == STATE_SENTINEL {
			logmes "ç•ªå…µã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã—ã¾ã—ãŸï¼ï¼ï¼"
		} else {
			logmes "ä½¿ç”¨ä¸­ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã—ã¾ã—ãŸ"
		}
		stop
	}

<<<<<<< HEAD
	link_free_list back_free_list(id), next_free_list(id)
	block_state(id) = STATE_USED

	return
=======
	class_position = next_free_list( sentinel(get_class_index_by_id(id)) ) // é–‹å§‹ä½ç½®å–å¾—

	while class_position >= 0 // ç•ªå…µã‹æœ«å°¾ã¾ã§æ¢ã™

		if class_position == id {
			link_free_list back_free_list(id), next_free_list(id)
			block_state(id) = STATE_USED
			return
		}
		class_position = next_free_list(class_position)
	wend

	logmes "å­˜åœ¨ã—ãªã„IDã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã—ãŸã€ã‚‚ã—ãã¯é–“é•ã£ãŸã‚¯ãƒ©ã‚¹ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™ã€‚"
	stop
>>>>>>> 84ab227fc0a0b60992330d10e6da4dcf9a8ee722
	
#deffunc resize_free_block int id, int newsize

	//æŒ‡å®šã•ã‚ŒãŸãƒ•ãƒªãƒ¼ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚µã‚¤ã‚ºã‚’å¤‰æ›´ã™ã‚‹

	if block_state(id) != STATE_FREE{
		logmes "ãƒ•ãƒªãƒ¼ãƒ–ãƒ­ãƒƒã‚¯ã§ãªã„ãƒ–ãƒ­ãƒƒã‚¯ã§ã™!!ã€resize_free_blockã€‘"
		return
	}
	
	_newclass = get_class_index(newsize)

	if get_class_index_by_id(id) == _newclass {
		//ã‚¯ãƒ©ã‚¹å¤‰å‹•ãªã—
		mem_size(id) = newsize
		return
	}
	
	//å‰Šé™¤ã—ã¦
	remove_from_free_list id

	//æ–°ãŸãªã‚µã‚¤ã‚ºã«æ›´æ–°ã—ã¦å†ç™»éŒ²
	mem_size(id) = newsize
	add_to_free_list id
	
	return
	
#deffunc add_to_free_list int id, local _class_

	_class_ = get_class_index(mem_size(id))

	class_top = sentinel( get_class_index(mem_size(id)) )

	//idã‚’å‰²ã‚Šè¾¼ã¾ã›ã‚‹
	link_free_list id, next_free_list(class_top)
	link_free_list class_top, id

	block_state(id) = STATE_FREE

	;debug_check_free_list_integrity

	return
	
#defcfunc get_free_block int size

	//æ¢ã—ã¦è¦‹ã¤ã‹ã£ãŸã‚‰å–ã‚Šå‡ºã™
	//æŒ‡å®šã‚µã‚¤ã‚ºã®ã‚¯ãƒ©ã‚¹ä»¥ä¸Šã®ç©ºããƒ–ãƒ­ãƒƒã‚¯ã‚’æ¢ã™ã‚ˆ
	
	start_node = next_free_list(sentinel(get_class_index(size)))
	
	//æ¤œç´¢é–‹å§‹ã€å„ã‚¯ãƒ©ã‚¹ã®ç•ªå…µã®ã‚µã‚¤ã‚ºã¯ãƒã‚¤ãƒŠã‚¹ãªã®ã§ãƒªã‚¹ãƒˆã®æœ€å¾Œã¾ã§ã„ã‘ã‚‹ã€‚

	while start_node >= 0 
		if mem_size(start_node) >= size{

			link_free_list back_free_list(start_node), next_free_list(start_node)

			block_state(start_node) = STATE_USED
			
			return start_node
		}
		start_node = next_free_list(start_node) 
	wend

	return -1
	
#deffunc shrink_block int target_id, int size

	//æœ‰åŠ¹ãªãƒ–ãƒ­ãƒƒã‚¯ã‚’æŒ‡å®šã‚µã‚¤ã‚ºã«ç¸®å°ã™ã‚‹(å˜ç´”ç¸®å°ãªã®ã§å†…å®¹ãŒå‰Šã‚‰ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚‹)

	if block_state(target_id) != STATE_USED: return 1 
	if size <= 0: return 2
	if size > mem_size(target_id): return 3

	if last_block_id != target_id{

		next_block_id = next_mem_id(target_id)
	
		if block_state(next_block_id) == STATE_FREE{
			
			assert next_mem_id(next_block_id) >= 0

			//æ¬¡ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒãƒ•ãƒªãƒ¼ãªã‚‰ã€æ¬¡ã®ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã¨ã‚µã‚¤ã‚ºã‚’å¤‰æ›´ã€‚
			offset(next_block_id) = offset(target_id) + size
			resize_free_block next_block_id, offset(next_mem_id(next_block_id)) - offset(next_block_id)
			
		}else: if offset(next_block_id) - offset(target_id) - size > FREELIST_THRESHOLD{
	
			//æ–°ãŸãªç©ºãç©ºé–“ã‚’ä½œæˆ
			new_free_id = get_new_id(mem_id_manager)
	
			link_blocks new_free_id, next_block_id
			link_blocks target_id, new_free_id
	
			offset(new_free_id) = offset(target_id) + size
			mem_size(new_free_id) = mem_size(target_id) - size
	
			//ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã«ç™»éŒ²
			add_to_free_list new_free_id
			
		}
	}
	
	mem_size(target_id) = size
	
	return 0
	
#defcfunc get_new_block int size
	if size <= 0{
		logmes "ã‚µã‚¤ã‚ºï¼ä»¥ä¸‹ã§ã¯ç¢ºä¿ã§ãã¾ã›ã‚“! ã€ get_new_block() ã€‘"
		
		return -1
	}
	
	newid = get_free_block(size)
	
	if newid >= 0{
		shrink_block newid, size //å¿…è¦ãªåˆ†ã ã‘ã«ã‚»ãƒƒãƒˆ
		memset memory_pool,0, mem_size(newid), offset(newid) //get_new_blockãªã®ã§ãŠæƒé™¤
		return newid
	}
	//ä»¥ä¸‹æ–°è¦ç™ºè¡Œ

	//æ–°ãŸã«IDã‚’ç¢ºä¿ã€‚ä¸€ç•ªå³ã®ãƒ–ãƒ­ãƒƒã‚¯ä½ç½®ã¨ãã®ã‚µã‚¤ã‚ºã®å…ˆã«æ–°ã—ã„ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰²ã‚Šå½“ã¦ã‚‹
	newid = get_new_id(mem_id_manager)
	
	mem_size(newid) = size

	if last_block_id >= 0{
		offset(newid) = offset(last_block_id) + mem_size(last_block_id)
		next_mem_id(last_block_id) = newid
	}else{
		offset(newid) = 0
	}

	if offset(newid) + size > MAX_EXPAND_LIMIT{

		//ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
		if last_block_id >= 0{
			next_mem_id(last_block_id) = -1
		}
		release_id mem_id_manager, newid
		
		logmes "ãƒ¡ãƒ¢ãƒªãŒã¨ã‚Œãªã‹ã£ãŸã‚ˆãƒ»ãƒ»ãƒ»ã€get_new_block()ã€‘"
		stop
		return -1
	}
	
	back_mem_id(newid) = last_block_id
	next_mem_id(newid) = -1
	block_state(newid) = STATE_USED

	last_block_id = newid

	memexpand memory_pool, offset(newid) + size
	memset memory_pool,0, mem_size(newid), offset(newid)
	
	return newid


#deffunc free_block int id
<<<<<<< HEAD
	//g—p’†‚ÌƒuƒƒbƒN‚ğ‰ğ•ú‚·‚éB¶‰E‚Ì—Ìˆæ‚ğ‹zû‚µ‚ÄAƒtƒŠ[ƒŠƒXƒg‚É•Ô‚·B

	if is_id_alive(mem_id_manager, id) == 0: return 0 //“ñdŠJ•úƒ`ƒFƒbƒN
	if block_state(id) != STATE_USED: return 0 // g—p’†‚Å‚Í‚È‚¢ƒuƒƒbƒN
=======

	//ä½¿ç”¨ä¸­ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾ã™ã‚‹ã€‚å·¦å³ã®é ˜åŸŸã‚’å¸åã—ã¦ã€ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã«è¿”ã™ã€‚

	if is_id_alive(mem_id_manager, id) == 0: return 0
	if block_state(id) != STATE_USED: return 0//ä½¿ç”¨ä¸­ã§ã¯ãªã„ãƒ–ãƒ­ãƒƒã‚¯
>>>>>>> 84ab227fc0a0b60992330d10e6da4dcf9a8ee722
	
	prev_id = back_mem_id(id) //å‰ã®ãƒ–ãƒ­ãƒƒã‚¯id
	next_id = next_mem_id(id) //æ¬¡ã®ãƒ–ãƒ­ãƒƒã‚¯id
	
	//ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã«last_block_idã‚’ç™»éŒ²ã—ãªã„ä»•æ§˜ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã®ãƒ­ã‚¸ãƒƒã‚¯ã€‚
	if id == last_block_id{
		//last_block_idã‚’è§£æ”¾ã™ã‚‹å ´åˆ
		if prev_id >= 0{
			if block_state(prev_id) != STATE_USED{
				//å·¦ã‚‚ãƒ•ãƒªãƒ¼
				remove_from_free_list prev_id
				if back_mem_id(prev_id) >= 0{
					next_mem_id(back_mem_id(prev_id)) = -1
				}
				last_block_id = back_mem_id(prev_id)
				release_id mem_id_manager, prev_id
			}else{
				//å·¦ã¯ä½¿ç”¨ä¸­
				last_block_id = prev_id
				next_mem_id(prev_id) = -1
			}
		}else{
			//è‡ªåˆ†ã ã‘ã®æ™‚ã®å‡¦ç†
			last_block_id = -1
		}
		//å…±é€šå‡¦ç†
		release_id mem_id_manager, id
		return 1
	}

	assert next_id >= 0 

	pattern_flag = 0

	if prev_id >= 0 {
		if block_state(prev_id) == STATE_FREE{
			pattern_flag |= 1 ;å·¦å´ãŒãƒ•ãƒªãƒ¼
		}
	}else{
		//ã€€å·¦ã«ãƒ–ãƒ­ãƒƒã‚¯ãŒãªãã¦ã‚‚å°æ–­ç‰‡åŒ–ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚ã€€ãƒ–ãƒ­ãƒƒã‚¯ãŒå·¦ã«ãªã„ã®ã§ã‚ã‚Œã°å·¦ç«¯ã¾ã§ã‚’é ˜åŸŸã¨ã™ã‚Œã°ã‚ˆã„ã€‚
		//ï¼ˆå³ç«¯ãŒå¤‰ã‚ã‚‰ãªã„ã‚ˆã†ã«éš™é–“ã‚’å¸åï¼‰
		mem_size(id) += offset(id)
		offset(id) = 0
	}

	if block_state(next_id) == STATE_FREE{
		pattern_flag |= 2 ;å³å´ãŒãƒ•ãƒªãƒ¼
	}


		
	switch pattern_flag
	case 0 //ã©ã¡ã‚‰ã«ã‚‚çµ±åˆãªã—
		left = offset(id)
		right = offset(next_id)
		
		if prev_id >= 0: left = offset(prev_id) + mem_size(prev_id)
		
		offset(id) = left
		mem_size(id) = right - left
		
		if mem_size(id) > FREELIST_THRESHOLD{
			//ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã«ç™»éŒ²
			add_to_free_list id
			
		}else{
			//å°æ–­ç‰‡ãªã®ã§ç„¡è¦–ã—ã€å‰å¾Œã‚’é€£çµã™ã‚‹
			link_blocks prev_id, next_id
			release_id mem_id_manager, id //idè¿”å´
		}
	swbreak
				
	case 1 //å·¦ã«ã®ã¿çµ±åˆ
		left = offset(prev_id)
		right = offset(next_id)
		//é€£çµæ›´æ–°
		resize_free_block prev_id, right - left
		
		link_blocks prev_id, next_id

		release_id mem_id_manager, id //idã¯æ¶ˆå¤±
	swbreak

	case 2 //å³ã«ã®ã¿çµ±åˆ
		assert next_mem_id(next_id) >= 0 //ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰ã€ã•ã‚‰ã«å³ãŒã‚ã‚‹ã€‚
		left = offset(id)
		right = offset(next_mem_id(next_id))
		if prev_id >= 0{
			left = offset(prev_id) + mem_size(prev_id)
		}
		
		resize_free_block next_id, right - left

		offset(next_id) = left
		//é€£çµæ›´æ–°
		link_blocks prev_id, next_id
		

		release_id mem_id_manager, id //idã¯æ¶ˆå¤±
	swbreak
	
	case 3 //å·¦å³ã«çµ±åˆ -> prev_idã«çµ±ä¸€ã™ã‚‹
		assert next_mem_id(next_id) >= 0
		left = offset(prev_id)
		right = offset(next_mem_id(next_id))

		resize_free_block prev_id, right - left

		remove_from_free_list next_id //nextã¯ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã«å­˜åœ¨ã™ã‚‹ã¯ãšãªã®ã§å‰Šé™¤

		//é€£çµæ›´æ–°
		link_blocks prev_id, next_mem_id(next_id)

		//æ¶ˆå¤±idã‚’è¿”å´
		release_id mem_id_manager, id
		release_id mem_id_manager, next_id
		swbreak
	swend

	#ifdef DEBUG_ALLOCATOR
	debug_check_link_integrity "free_block pattern_flag -> " + pattern_flag
	debug_check_free_list_integrity
	debug_check_memory_pool_integrity
	#endif
	
	return 1
	
#deffunc debug_check_link_integrity str lab

	list_count = get_block_count()

	if list_count == 0 {
		return 0
	}

	//é–‹å§‹ç‚¹æœç´¢

	count = 0; ãã‚‚ãã‚‚ã®ã‚«ã‚¦ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
	start_point = -1
	foreach_id mem_id_manager, vid
		if block_state(vid) == STATE_SENTINEL: continue //ç•ªå…µã‚¹ã‚­ãƒƒãƒ—
		if back_mem_id(vid) == -1{
			if start_point != -1 {
				logmes "[ãƒªãƒ³ã‚¯ãƒã‚§ãƒƒã‚¯å¤±æ•—] é–‹å§‹ç‚¹ãŒè¤‡æ•°è¦‹ã¤ã‹ã£ãŸï¼š" + lab
				return 1
			}
			start_point = vid
		}
		count++
	foreach_end

	if count != list_count{
		logmes "ã‚«ã‚¦ãƒ³ãƒˆãƒã‚°"
		stop
	}

	if start_point == -1 {
		logmes "[ãƒªãƒ³ã‚¯ãƒã‚§ãƒƒã‚¯å¤±æ•—] é–‹å§‹ç‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã„ï¼š" + lab
		return 1
	}

	//é–‹å§‹ç‚¹ã‹ã‚‰æœ€å¾Œã¾ã§åˆ°é”ã§ãã‚‹ã‹ã€ãƒãƒƒã‚¯ãƒªãƒ³ã‚¯ã¨å¾ªç’°ã‚‚å«ã‚ã¦ãƒã‚§ãƒƒã‚¯
	count = 0
	__prev_id = -1
	
	while start_point != -1
		if back_mem_id(start_point) != __prev_id {
			logmes "[ãƒªãƒ³ã‚¯ãƒã‚§ãƒƒã‚¯å¤±æ•—] " + strf("%d > (%d=%d) < %d", __prev_id, start_point, back_mem_id(start_point), start_point) + "æ¬¡ã®å‰ãŒãƒªãƒ³ã‚¯ã—ã¦ã„ã¾ã›ã‚“\n" + lab
			return 1
		}
		if count > list_count{
			logmes "[ãƒªãƒ³ã‚¯ãƒã‚§ãƒƒã‚¯å¤±æ•—] å¾ªç’°æ¤œå‡º: " + lab
			return 1
		}
		__prev_id = start_point
		start_point = next_mem_id(start_point)
		count++
	wend
	
	if count != list_count{
		logmes "[ãƒªãƒ³ã‚¯ãƒã‚§ãƒƒã‚¯å¤±æ•—] ä½¿ç”¨ä¸­ã®ãƒ–ãƒ­ãƒƒã‚¯æ•°ã¨ãƒªãƒ³ã‚¯æ•°ãŒä¸€è‡´ã—ãªã„ï¼š" + lab
		return 1
	}
	
	//ç®¡ç†ã—ã¦ã„ã‚‹æœ€å¾Œã®ãƒ–ãƒ­ãƒƒã‚¯IDã¨ãƒªãƒ³ã‚¯ã®æœ€å¾Œã®ãƒ–ãƒ­ãƒƒã‚¯IDãŒä¸€è‡´ã™ã‚‹ã‹ç¢ºèª
	if __prev_id != last_block_id{
		logmes "[ãƒªãƒ³ã‚¯ãƒã‚§ãƒƒã‚¯å¤±æ•—] æœ€å¾Œã®ãƒ–ãƒ­ãƒƒã‚¯ãŒä¸æ­£ï¼š" + lab
		return 1
	}
	
	return 0
	ã€€
#deffunc debug_check_memory_pool_integrity
	if last_block_id == -1: return

	//å³ã‹ã‚‰ãƒã‚§ãƒƒã‚¯ã€ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—ã—ãŸã‚Šã€é›¢ã‚Œã™ãã¦ã„ãªã„ã‹ï¼Ÿ
	start_point = last_block_id
	
	while start_point >= 0
	
		offset_point = offset(start_point)
		
		if offset_point < 0{
			logmes "ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒç¯„å›²å¤–ã§ã™ï¼ˆãƒã‚¤ãƒŠã‚¹ï¼‰"
			stop
		}

		pre_point = start_point
		start_point = back_mem_id(start_point) //å·¦ã®ãƒ–ãƒ­ãƒƒã‚¯ã«ç§»å‹•

		if start_point < 0{
			if offset_point > FREELIST_THRESHOLD{
				logmes "å·¦ç«¯ã«è¡Œæ–¹ä¸æ˜ç©ºé–“ãŒã‚ã‚Šã¾ã™"
				stop
			}
			_break
		}

		gap = (offset_point) - (offset(start_point) + mem_size(start_point))
		if gap < 0{
			logmes "é ˜åŸŸãŒã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—ã—ã¦ã„ã¾ã™ :: " + start_point + " <> " + pre_point + " ::\n"  + strf("(%d,%d) <-> (%d,%d)", offset(start_point), offset(start_point) + mem_size(start_point) , offset(pre_point), offset(pre_point) + mem_size(pre_point)) 
			stop
		}
		if gap > FREELIST_THRESHOLD{
			logmes "è¡Œæ–¹ä¸æ˜ç©ºé–“ã‚ã‚Š :: " + start_point + " <> " + pre_point + " ::\n"  + strf("(%d,%d) <-> (%d,%d)", offset(start_point), offset(start_point)+ mem_size(start_point) , offset(pre_point), offset(pre_point) + mem_size(pre_point)) 
			stop
		}
		
	wend
		
	return

#deffunc expand_block int oldid, int newsize
	/*
	ãƒ–ãƒ­ãƒƒã‚¯ã®æ‹¡å¼µã‚’è©¦ã¿ã‚‹ã€‚
	å·¦å³ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç¢ºèªã—ã€æ‹¡å¼µå¯èƒ½ã§ã‚ã‚Œã°æ‹¡å¼µã™ã‚‹ã€‚
	æ‹¡å¼µã§ããªã‹ã£ãŸå ´åˆã¯ã€å·¦å³ã®é ˜åŸŸã‚’å¸åã—ã¦ã€ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç§»å‹•ã™ã‚‹ã€‚
	*/
	if block_state(oldid) != STATE_USED: return 0
	if newsize <= 0: return 0

	//è‡ªåˆ†ãŒæœ€å¾Œã®ãƒ–ãƒ­ãƒƒã‚¯ã®å ´åˆ
	if last_block_id == oldid {
		end_required = offset(oldid) + newsize
		if end_required > MAX_EXPAND_LIMIT {
			dialog strf("ãƒ—ãƒ¼ãƒ«æ‹¡å¼µé™ç•Œã‚’è¶…ãˆã¦ã„ã¾ã™ï¼\n æ‹¡å¼µé™ç•Œ = %d\n è©¦è¡Œã‚µã‚¤ã‚º = %d \n è¦æ±‚ã‚µã‚¤ã‚º = %d", MAX_EXPAND_LIMIT, end_required, newsize)
			end
			return 0
		}
		memexpand memory_pool, end_required 
		mem_size(oldid) = newsize
		return 1
	}

	offset_original = offset(oldid)
	size_original = mem_size(oldid)
	mem_size(oldid) = newsize //æ–°ã—ã„ã‚µã‚¤ã‚ºã‚’ã‚»ãƒƒãƒˆ

	if try_expand_right(oldid, newsize,offset_original, size_original): return 1
	if try_expand_left(oldid, newsize,offset_original, size_original): return 1
	
	return tryrelocate_block(oldid, newsize, offset_original, size_original)

#defcfunc try_expand_right int oldid, int newsize, int originaloffset, int originalsize

	//å³æ‹¡å¼µã‚’è©¦ã¿ã‚‹ã€‚ä¸å¯èƒ½ã ã£ãŸå ´åˆã€ãƒ•ãƒªãƒ¼ãƒ–ãƒ­ãƒƒã‚¯ã®å¸åã ã‘è¡Œã†ã€‚
	
	nid = next_mem_id(oldid)
	if nid >= 0{
		if block_state(nid) == STATE_FREE{
			gap = offset(next_mem_id(nid)) - (originaloffset)
			if newsize <= gap{
				if gap <= FREELIST_THRESHOLD + newsize{
					remove_free_block nid
				}else{
					//å³ã‚ªãƒ•ã‚»ãƒƒãƒˆç§»å‹•
					offset(nid) = originaloffset + newsize
					//å³ã®ã‚µã‚¤ã‚ºå¤‰æ›´
					resize_free_block nid, offset(next_mem_id(nid)) - offset(nid)
					assert mem_size(nid) > FREELIST_THRESHOLD

				}
				;debug_check_link_integrity "å³å´æ‹¡å¼µæˆåŠŸ free"
				return 1
			}
			//å³ã®ãƒ•ãƒªãƒ¼ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰Šé™¤
			remove_free_block nid
		}else{
<<<<<<< HEAD
			
			if newsize <= offset(nid) - originaloffset{//‰EƒuƒƒbƒN‚Ü‚Å‚ÌŒ„ŠÔ‚ÅOK
				;debug_check_link_integrity "‰E‘¤Šg’£¬Œ÷ used"
=======
			if newsize <= offset(nid) - (originaloffset + newsize){//å³ãƒ–ãƒ­ãƒƒã‚¯ã¾ã§ã®éš™é–“ã§OK
				;debug_check_link_integrity "å³å´æ‹¡å¼µæˆåŠŸ used"
>>>>>>> 84ab227fc0a0b60992330d10e6da4dcf9a8ee722
				return 1
			}
		}
	}
	return 0
#defcfunc try_expand_left int oldid, int newsize, int originaloffset, int originalsize

	//å·¦æ‹¡å¼µã‚’è©¦ã¿ã‚‹ã€‚ä¸å¯èƒ½ã ã£ãŸå ´åˆã€ãƒ•ãƒªãƒ¼ãƒ–ãƒ­ãƒƒã‚¯ã®å¸åã ã‘è¡Œã†ã€‚

	//å·¦å´ã®ãƒã‚§ãƒƒã‚¯é–‹å§‹
	bid = back_mem_id(oldid)
	
	right = offset(next_mem_id(oldid))
	if bid >= 0{
		if block_state(bid) == STATE_FREE{
			gap = right - offset(bid)
			if newsize <= gap{//æ‹¡å¼µå¯èƒ½
			
				//å·¦ã®ä½ç½®ã‚’è‡ªåˆ†ã®ã‚‚ã®ã«ã™ã‚‹
				offset(oldid) = offset(bid) 
				memcpy memory_pool, memory_pool, originalsize, offset(oldid), originaloffset

				if gap <= FREELIST_THRESHOLD + newsize{
					
					remove_free_block bid //å·¦ãƒ–ãƒ­ãƒƒã‚¯ã‚’å‰Šé™¤

				}else{
					swap_adjacent_blocks oldid //éš£æ¥ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒªãƒ³ã‚¯ã‚’å…¥ã‚Œæ›¿ãˆ(æŒ‡å®šIDã¨ãã®å·¦éš£ã®ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒªãƒ³ã‚¯ã‚’å…¥ã‚Œæ›¿ãˆã‚‹)

					//å·¦ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’IDãƒ–ãƒ­ãƒƒã‚¯ã®å³ç«¯ã«ã‚»ãƒƒãƒˆ
					offset(bid) = offset(oldid) + newsize
					//å·¦ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚µã‚¤ã‚ºå¤‰æ›´
					resize_free_block bid, right - offset(bid)
					assert mem_size(bid) > FREELIST_THRESHOLD
					
				}
				
				;debug_check_link_integrity "å·¦å´æ‹¡å¼µæˆåŠŸ free"
				return 1
			}
			
			remove_free_block bid
			
		}else{
			if newsize <= right - (offset(bid) + mem_size(bid)){ //å·¦ãƒ–ãƒ­ãƒƒã‚¯ã¾ã§ã®éš™é–“ã§åã¾ã‚‹
			
				//ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å·¦ã«è©°ã‚ã‚‹
				offset(oldid) = offset(bid) + mem_size(bid)
				memcpy memory_pool, memory_pool, originalsize, offset(oldid), originaloffset

				debug_check_memory_pool_integrity
				
				;debug_check_link_integrity "å·¦å´æ‹¡å¼µæˆåŠŸ used"
				return 1
			}
		}
	}
	
	return 0
	
#defcfunc tryrelocate_block int oldid, int newsize, int originaloffset, int originalsize
	/*	
	ï¼”ã¨ã€ç©ºãã‚¹ãƒšãƒ¼ã‚¹ï¼ˆï¼™ï¼‰ã‚’å…¥ã‚Œæ›¿ãˆã‚‹ã¨ãã€
	
	1,2,3,(3,4,5),5,6,7,8,(8,9,10),10,11,11
					â†“
	1,2,3,(3,9,5),5,6,7,8,(8,4,10),10,11,11

	ã“ã®ã‚ˆã†ã«çµ„ã¿æ›¿ãˆã‚Œã°ã‚ˆã„ã€‚

	ã“ã®æ“ä½œã¯ãƒ¡ãƒ¢ãƒªãƒ—ãƒ¼ãƒ«ä¸Šã«ã¯ã€ä¸€åˆ‡å½±éŸ¿ã‚’ä¸ãˆãªã„ãŸã‚ã€ãƒ¡ãƒ¢ãƒªã‚³ãƒ”ãƒ¼æ“ä½œã¯åˆ¥æ¬¡å…ƒã§è€ƒãˆã¦ã‚ˆã„ã€‚
	ãƒ¡ãƒ¢ãƒªä¸Šã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚„ã‚µã‚¤ã‚ºã¯å˜ç´”ãªswapæ“ä½œã§OK

	å®Œå…¨ã«æƒ…å ±ã‚’äº¤æ›ã—ãŸå¾Œã€
	å…ƒå±…ãŸãƒªãƒ³ã‚¯ä¸Šã®å ´æ‰€ã€ã¤ã¾ã‚Šæ–°ã—ãç¢ºä¿ã—ãŸãƒ–ãƒ­ãƒƒã‚¯IDã‚’å‰Šé™¤ã™ã‚‹ã€‚

	1,2,3,(3,9,5),5,6,7,8,(8,4,10),10,11,12
			â†‘ï¼™ãŒãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã«å…¥ã‚‹ã€‚

	ã“ã‚Œã§å®Œäº†ã€‚

	last_block_id ã¯ãƒªãƒ³ã‚¯ã®æœ€å¾Œã‚’è¡¨ã™ã€‚
	oldid == last_blockã ã£ãŸã¨ãã€æ§‹é€ äº¤æ›å¾Œã¯newidãŒãƒªãƒ³ã‚¯ã®æœ€å¾Œã‚’è¡¨ã™ã€‚å‰Šé™¤ã™ã‚‹ã®ã§å•é¡Œãªã—
	newid == last_blockã®ã¨ãã¯ã€æ§‹é€ äº¤æ›å¾Œã¯lastblockã¯oldidã«ãªã‚‹ãŸã‚ã€å¤‰æ›´ãŒå¿…è¦ã€‚
	
	*/

	assert next_mem_id(oldid) >= 0
	assert block_state(next_mem_id(oldid)) == STATE_USED
	
	//å·¦ã®éš™é–“è¨ˆç®—
	if back_mem_id(oldid) >= 0{
		assert block_state(back_mem_id(oldid)) == STATE_USED 
		//å·¦å´ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚‹å ´åˆ
		offset(oldid) = offset(back_mem_id(oldid)) + mem_size(back_mem_id(oldid))
	}else{
		offset(oldid) = 0
	}
	
	mem_size(oldid) = offset(next_mem_id(oldid)) - offset(oldid) //å³å´ã®ãƒ–ãƒ­ãƒƒã‚¯ã¾ã§ã®ã‚µã‚¤ã‚ºã‚’ã‚»ãƒƒãƒˆ

	//ç§»å‹•å¯èƒ½ãƒ–ãƒ­ãƒƒã‚¯ã‚’é¸æŠ
	newid = get_free_block(newsize)
	
	if newid = -1{
		//æ–°ãŸãªãƒ–ãƒ­ãƒƒã‚¯ã‚’ç¢ºä¿
		newid = get_new_block(newsize)
		if newid == -1{
			logmes "ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ç§»å‹•æ™‚ã«é ˜åŸŸã®ç¢ºä¿ã«å¤±æ•—ã—ã¾ã—ãŸ -> " + newsize
			return 0
		}
		
		if last_block_id == newid{
			last_block_id = oldid
		}
		
	}else{
		assert mem_size(newid) >= newsize
		shrink_block newid, newsize
	}
	
	//æ§‹é€ äº¤æ›
	bnewid = back_mem_id(newid)
	nnewid = next_mem_id(newid)
	boldid = back_mem_id(oldid)
	noldid = next_mem_id(oldid)
	back_mem_id(newid) = boldid: if boldid >= 0: next_mem_id(boldid) = newid
	next_mem_id(newid) = noldid: if noldid >= 0: back_mem_id(noldid) = newid
	back_mem_id(oldid) = bnewid: if bnewid >= 0: next_mem_id(bnewid) = oldid
	next_mem_id(oldid) = nnewid: if nnewid >= 0: back_mem_id(nnewid) = oldid

	//æ§‹é€ äº¤æ›å®Œäº†
	
	//ãã‚Œãã‚Œã®ãƒ–ãƒ­ãƒƒã‚¯ã®ã€Œå†…å®¹ã€ã‚’å¾©å…ƒ
	memcpy memory_pool, memory_pool, originalsize, offset(newid), originaloffset
	swap offset(newid), offset(oldid)
	swap mem_size(newid), mem_size(oldid)

		
	free_block newid //è§£æ”¾


	return 1

#deffunc remove_free_block int target_id
<<<<<<< HEAD

    if block_state(target_id) != STATE_FREE: return 0 // ƒtƒŠ[ƒuƒƒbƒN‚Ì‚İ‹–‰Â
=======
    if is_id_alive(mem_id_manager, target_id) == 0: return 0 // ç„¡åŠ¹ãªID
    if block_state(target_id) != STATE_FREE: return 0 // ãƒ•ãƒªãƒ¼ãƒ–ãƒ­ãƒƒã‚¯ã®ã¿è¨±å¯
>>>>>>> 84ab227fc0a0b60992330d10e6da4dcf9a8ee722
    
    remove_from_free_list target_id // ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
    link_blocks back_mem_id(target_id), next_mem_id(target_id) // å‰å¾Œã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒªãƒ³ã‚¯
    release_id mem_id_manager, target_id// IDã‚’è¿”å´
    
return 1 // æˆåŠŸ

#deffunc swap_adjacent_blocks int nowid
	// æŒ‡å®šã•ã‚ŒãŸIDã®ãƒ–ãƒ­ãƒƒã‚¯ã¨ãã®å·¦éš£ã®ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒªãƒ³ã‚¯ã®ã¿ã‚’å…¥ã‚Œæ›¿ãˆã‚‹
	
	_prev_id = back_mem_id(nowid)
	_next_id = next_mem_id(nowid)
	
	link_blocks back_mem_id(_prev_id), nowid
	link_blocks nowid, _prev_id
	link_blocks _prev_id, _next_id
	
	return
	
#deffunc link_blocks int _prev_id_, int _next_id_
    if _prev_id_ >= 0: next_mem_id(_prev_id_) = _next_id_
    if _next_id_ >= 0: back_mem_id(_next_id_) = _prev_id_
	return
#deffunc link_free_list int _prev_id_, int _next_id_
    if _prev_id_ >= 0: next_free_list(_prev_id_) = _next_id_
    if _next_id_ >= 0: back_free_list(_next_id_) = _prev_id_
    return
	
///////////////////
//////å¯è¦–åŒ–///////
///////////////////

#deffunc draw_memory_pool_with_labels int ysize, int yoffset, array chenged_ids, local sclass, local col, local ofs, local _size
	#const PIXEL 1
	redraw 2
<<<<<<< HEAD
	color 0,255,0 ; g‚í‚ê‚Ä‚¨‚ç‚¸AƒtƒŠ[ƒŠƒXƒg‚É‚à“o˜^‚³‚ê‚Ä‚¢‚È‚¢
	boxf 0,yoffset, limit(get_memory_pool_size() * PIXEL,,ginfo(12)), yoffset+ysize
=======
	color 0,255,0 ; ä½¿ã‚ã‚Œã¦ãŠã‚‰ãšã€ãƒ•ãƒªãƒ¼ãƒªã‚¹ãƒˆã«ã‚‚ç™»éŒ²ã•ã‚Œã¦ã„ãªã„
	boxf 0,yoffset, limit(get_memory_pool_size() * PIXEL,,ginfo(12)),yoffset+ysize
>>>>>>> 84ab227fc0a0b60992330d10e6da4dcf9a8ee722
	
	foreach_id mem_id_manager, vid
	
		if block_state(vid) == STATE_SENTINEL: continue
		ofs = offset(vid)
		_size = mem_size(vid)
		sclass = get_class_index(_size)
		col = get_color_by_class(sclass)

		//é ˜åŸŸæç”»
		
		//é ˜åŸŸã®è‰²åˆ†ã‘
		if block_state(vid) == STATE_USED{
			color $D3,$D3,$D3
		}else: if is_in_array(vid, changed_ids){
			color 255,200,0
		}else{
			color col>>16&255,col>>8&255,col&255
		}
		
		boxf ofs*PIXEL+1,yoffset, (ofs + _size)*PIXEL-1, yoffset+ysize

		color 0,0,0
		pos ofs*PIXEL+1,yoffset + ysize/3
		mes _size
		
		//æ–‡å­—åˆ—ã§ä½¿ç”¨ä¸­ãªã‚‰ãã‚Œã‚’å¯è¦–åŒ–
		color 255,0,0
		ä½¿ç”¨é‡ = strlen(read_mem_str(vid))
		boxf ofs*PIXEL+1, yoffset+ysize - ysize/4, (ofs + ä½¿ç”¨é‡)*PIXEL-1, yoffset+ysize - ysize/9

		//ãƒ–ãƒ­ãƒƒã‚¯ID
		color 0,0,0
		pos (ofs + 2 ) * PIXEL, yoffset + 2
		mes vid
		//ã‚¯ãƒ©ã‚¹
		pos (ofs + 2 ) * PIXEL, yoffset + 2 + ysize/2
		mes sclass
		//ä¸¡å´ã®åŒºåˆ‡ã‚Šç·š
		line ofs * PIXEL                 , yoffset, ofs*PIXEL, yoffset+ysize
		line (ofs + mem_size(vid)) * PIXEL, yoffset, (ofs+mem_size(vid)) * PIXEL,yoffset+ysize
		
	foreach_end
	redraw
	return
	
#defcfunc get_color_by_class int _class
	switch _class
	case 0 : return $ff6666
	case 1 : return $ff9933 
	case 2 : return $ffff66
	case 3 : return $66cc66 
	case 4 : return $3399ff 
	case 5 : return $6666ff 
	case 6 : return $cc66ff
	case 7 : return $ff66cc
	case 8 : return $33cc99
	case 9 : return $999999
	default: return $333333
	swbreak
	swend
return
#defcfunc is_in_array int _value, array a
	for i,, length(a)
		if a(i) == _value : return 1
	next
	return 0

////////////////////////
/////å†…éƒ¨æƒ…å ±å–å¾—///////
////////////////////////

#defcfunc get_block_offset int id
	return offset(id)

#defcfunc get_block_size int id
    return mem_size(id)

//ãƒ–ãƒ­ãƒƒã‚¯ãŒæ“ä½œå¯èƒ½ã‹ã©ã†ã‹
#defcfunc is_usable_block int id
	return block_state(id) == STATE_USED

//ãƒ¡ãƒ¢ãƒªãƒ—ãƒ¼ãƒ«ä¸Šã«å­˜åœ¨ã™ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã®æ•°ï¼ˆç©ºãå«ã‚€ï¼‰
#defcfunc get_block_count
	return get_using_count(mem_id_manager) - CLASS_NUM

//ç™ºè¡Œã—ãŸæœ€å¤§ã®IDç•ªå·
#defcfunc get_block_max_id
	return get_max_id(mem_id_manager)

#defcfunc get_memory_pool_size
	return varsize(memory_pool)
	
#defcfunc get_memory_pool_size_max
	return MAX_EXPAND_LIMIT

///////////////////	
//////æ“ä½œAPI//////
///////////////////

//æ–‡å­—åˆ—ã¨ã—ã¦æ“ä½œ
#deffunc write_mem_str int id, str value, int offset_in_block

	if block_state(id) != STATE_USED: return
	if offset_in_block < 0: return
	
	sz = strlen(value)
	vv = value
	if mem_size(id) < offset_in_block + sz{
		expand_block id, offset_in_block + sz
	}
	memcpy memory_pool, vv, sz, offset(id) + offset_in_block //szåˆ†ã ã‘æ›¸ãè¾¼ã‚€
	return

#deffunc re_write_mem_str int id, str value

	if block_state(id) != STATE_USED: return
	
	sz = strlen(value)
	vv = value
	if mem_size(id) < sz{
		expand_block id, sz
	}
	memset memory_pool, 0, mem_size(id), offset(id)
	memcpy memory_pool, vv, sz, offset(id)
	return

#defcfunc read_mem_str int id, int offset_in_block
	if block_state(id) != STATE_USED: return ""
	if offset_in_block < 0: return ""
	if offset_in_block > mem_size(id): return ""

	copy_size = mem_size(id) - offset_in_block
	
	dupptr s, varptr(memory_pool) + offset(id) + offset_in_block, copy_size, 2
	return strmid(s, 0, copy_size) //æ–‡å­—åˆ—ã¨ã—ã¦åˆ‡ã‚Šå‡ºã™
	
#deffunc append_str int id, str value
	write_mem_str id, read_mem_str(id) + value
	return
	
#deffunc insert_str int id, str value, int write_pos
	tmp = read_mem_str(id)
	write_mem_str id, strmid(tmp, 0, write_pos) + value + strmid(tmp, write_pos, $FFFFFFF)
	return

//ãƒã‚¤ãƒŠãƒªæ“ä½œ
#deffunc poke_block int id, var a, int offset_in_block

	if offset_in_block < 0: return
	if block_state(id) != STATE_USED: return

	v_size = varsize(a)
	required = offset_in_block + v_size
	if mem_size(id) < required {
		expand_block id, required
	}

	usable = mem_size(id) - offset_in_block
	memcpy memory_pool, a, limit(v_size,,usable), offset(id) + offset_in_block
	return
	
#deffunc peek_block int id, var a, int offset_in_block
	if block_state(id) != STATE_USED: return
	if offset_in_block < 0: return
	if offset_in_block > mem_size(id): return

	memcpy a, memory_pool, limit(mem_size(id) - offset_in_block,, varsize(a)), 0, offset(id) + offset_in_block
	return
	
#deffunc Lpoke_block int id, int p1, int offset_in_block

	if mem_size(id) < offset_in_block + 4 {
		expand_block id, offset_in_block + 4
	}
	
	lpoke memory_pool, offset(id) + offset_in_block, p1
	return

#deffunc copy_block int id, var a
	dupptr a, varptr(memory_pool) + offset(id), mem_size(id), 2
	return

#global
init_memory_pool

#ifndef swap
#module
#deffunc swap var a, var b
	tmp = a
	a = b
	b = tmp
	return
#global
#endif

#endif
