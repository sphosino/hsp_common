#ifndef ringbuffer
#module ringbuffer max_num, size, data, count, write_index, read_index

#define plus1(%1) %1 = (%1 + 1) \ max_num

#modinit int _size, int _max_num
	init_ringbuffer thismod, _size, _max_num
	return
	
#modfunc init_ringbuffer int _size, int _max_num
	max_num = limit(_max_num, 1)
	size = limit(_size, 64)
	sdim data, size, max_num
	reset_ringbuffer thismod
	return
	
#modfunc reset_ringbuffer
	write_index = 0
	read_index = 0
	count = 0
	return

#define data_push :\
	memcpy data(write_index), values, limit(size,, varsize(values)):\
	plus1 write_index
	
#modfunc r_push var values, int no_resize

	if count == max_num{
		if no_resize{
			data_push
			plus1 read_index
		}else{
			resize thismod
			data_push
			count++
		}
	}else{
		data_push
		count++
	}

	return

#modfunc _r_shift var values //命令呼び出し用
#modcfunc r_shift var values //関数呼び出し用

	if count{
		count--
		memcpy values, data(read_index), limit(size,, varsize(values))
		plus1 read_index
		return 1
	}
	
	return 0


#modfunc local resize
	
	sdim tmp, size, max_num

	old_count = count

	repeat old_count
		_r_shift thismod, tmp(cnt)
	loop

	max_num *= 2
	init_ringbuffer thismod, size, max_num

	repeat old_count
		memcpy data(write_index), tmp(cnt), size
		plus1 write_index
	loop
	count = old_count
	
	return

#modcfunc get_ringbuffer_count
	return count
#modcfunc get_ringbuffer_max_num
	return max_num
#modcfunc get_ringbuffer_size
	return size
#global
#endif
#include "d3m.hsp" // 時間計測用（なければ gettime 等で代用してください）

//以下テストコード
#if 001
#ifdef _debug

#undef mes
#define mes(%1) mes@hsp %1: logmes %1

// --- テスト開始 ---


// モジュールの初期化
// 1スロット64バイト、初期最大数10（小さめにしてリサイズを誘発させる）
newmod rb, ringbuffer, 64, 10

mes "--- リングバッファ負荷テスト開始 ---"

// 1. 高速追加・リサイズテスト
count_test = 10000
t1 = d3timer()

repeat count_test
    tmp = "Data No." + cnt
    r_push rb, tmp
loop

t2 = d3timer()
mes "" + count_test + "件のプッシュ完了（自動リサイズ含む）"
mes "所要時間: " + (t2 - t1) + "ms"
mes "最終バッファサイズ: " + get_ringbuffer_max_num(rb)

// 2. 整合性チェック（最初と最後のデータが正しいか）
mes "\n--- データ整合性チェック ---"
success = 1
first_val = ""
last_val = ""

repeat count_test
    sdim res, 64
    if r_shift(rb, res) {
        if (cnt == 0) : first_val = res
        if (cnt == count_test - 1) : last_val = res
    } else {
        mes "エラー: " + cnt + "件目でデータが途切れました"
        success = 0
        break
    }
loop

if success {
    mes "全件取り出し成功！"
    mes "最初のデータ: " + first_val + " (期待値: Data No.0)"
    mes "最後のデータ: " + last_val + " (期待値: Data No.9999)"
}

// 3. 巨大スロットでのリサイズ負荷
mes "\n--- 巨大スロット(1MB x 100件)テスト ---"
newmod rb_heavy, ringbuffer, 1024*1024, 2
sdim bigdata, 1024*1024
memset bigdata, 'A', 1024*1024

t3 = d3timer()
repeat 100
    r_push rb_heavy, bigdata
loop
t4 = d3timer()

mes "1MB x 100件完了: " + (t4 - t3) + "ms"
mes "最終最大数: " + get_ringbuffer_max_num(rb_heavy)

stop

#undef mes
#define global mes mes@hsp

#endif
#endif